Морфологический разбор
~~~~~~~~~~~~~~~~~~~~~~

для того чтобы найти слово в словаре, сначала надо определить его уникальный номер
для этого надо провести своеобразный морфологический разбор:
слово состоит из основы и окончания, основа хранится в базе основ, 
окончание хранится в базе окончаний
1. слово постепенно обрубается с конца
   каждое окончание проверяется, на то возможно ли оно
2. если окончание валидное, значит разбиение полагается верным и ищется
   основа слова в база основ
3. если нашли и основу, то ей соответствует несколько возможных классов окончаний (sik)
   из них оставляем только те варианты чьи классы окончаний содержут наше окончание.
Специальное окончание '#' означает пустое окончание.

Если после такого честного способа ничего не было найдено, то могут быть предприняты
дополнительные усилия, например отрезание специального вида приставок (ly,ся), попытки 
замены e на ё, махинации с формами немецких слов, и так далее. Все эти ухищрения пока не
реализованы.

База основ:
~~~~~~~~~~~
ключом в базе stem является собтвенно основа,
значением является:
первый байт - тип c точки зрения использования заглавных букв (не используется),
а далее вектор семибайтных кодов, каждый код содержит:
3 байта - номер слова (4 байтовый long ужатый до 3-х байт)
2 байта - sik
2 байта - lgk

База классов окончаний:
~~~~~~~~~~~~~~~~~~~~~~~~
База представляет собой особую структуру _не_ формата BTree.
Как искать определяется следующим образом:
1. сначала по смещению sik находится местоположение строки класса.
2. Потом уже идёт работа со строкой класса.

Следует сразу отметить, что некоторые номера sik зарезервированы под другие нужды:
например номера с 700 до 720  (по другой версии до 800 (для английского))
зарезервированы под маски допустимых форм для разных lgk.

В строке имеются или окончания или управляющие коды.
Записи упорядочены так, что их номер соответствует битику в коде формы.
Соответственно в результате можно найти все формы данного слова. Например слово 'стол', 
соответствует двум падежам.
Управляющие последовательности (их значение больше чем SIK_MAX_END_NUMBER):
SIK_CLEAR_END_OF_CLASS - конец класса.

SIK_SAME_END - мы делаем всё то же, что и обычно, только не увеличиваем
счётчик позиции окончания в строке. То есть если мы запросим Большой и
Большою, оба слова будут найдены, и для обоих совпадут переменные results,
потому что -ой и -ою в классе заданы как альтернативные формы.
Но, кстати, там где-то есть переменная, которая указывает, какая именно
форма совпала - основная или альтернативная (которых в принципе через
запятую можно задать сколько угодно). Впрочем, это точно в словаре не
использется, сделано с запасом на будущее

SIK_NO_END - данная форма у слова отсутствует, пропускаем соотв. битик.

SIK_PRICH_START -  в классе глагола сначала идут формы глагола, а в конце -
ссылка на четыре возможные класса причастия. Причастия изменяются как
прилагательные и целиком в глагольный класс не влезают. Соответственно, в
классе глагола после кода SIK_PRICH_START идут ссылки на классы причастий.

После того так найдено то или иное окончание надо посмотреть на lgk слова, найденное
ранее в базе основ и проанализировать, допустима ли для данного lgk такая форма.
( Не все формы данного класса могут присутствовать в парадигме текущего слова.
Например, класс русского существительного предусматривает 12 форм, 6
единственного и 6 множественного числа. Вообще, если присмотреться, реально
в таблице классов задано 14 форм - формы винительного падежа могут быть
разные в зависимости от одушевлённости, винить Дворник и винить Дворника -
но это сейчас неважно.
Однако, некоторые слова употредляются только в единственном числе, то есть
класс у них будет такой же, как и у других нормальных слов, но старшие шесть
форм в нём не используются.
Это проверяется по lgk - если в lgk существительного не выставлен бит
N_PLURAL, то у слова нет форм множественного числа, и они не будут
проверяться. )


Поиск в индексе
~~~~~~~~~~~~~~~

База Multitran изначально расчитана на то что будет производится поиск не отдельных слов,
а слов или фраз. Для этого существует индекс (база с расширением .xxD), осуществляющая соответсвие
фразы и словарных статей.
Ключ базы: Фраза кодируется последовательностью трёхбайтовых кодов слов,
Значание ключа: сначала два байта - код тематики, удобно для быстрого отсеивания при необходимости, а потом
серия трехбайтовых кодов словарных статей.

На вход поиска подаётся результат морфологического разбора, то есть набор слов с разными вариациями
кодов, на выходе мы должны найти последовательно самые длинные фразы из индекса накрывающие исходную
фразу (возможны разные стратегии поиска лучшего накрытия, пока используется только такой).

Возможно проведение дополнительных махинаций для оптимизации хранения фраз:
например убирание артиклей и убирание 'to' в начале слов для английского
(пока не реализовано).

После такой обработки мы получаем уже индексы словарных статей, то есть практически уже мы готовы
сообщить пользователю подстрочный перевод фразы.
